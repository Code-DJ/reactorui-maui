<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     MauiReactor.Scaffold Version: <#= Assembly.GetExecutingAssembly().GetName().Version #>
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Reflection;

using MauiReactor.Animations;
//using MauiReactor.Shapes;
using MauiReactor.Internals;

namespace MauiReactor
{
    public partial interface I<#= TypeName() #>
    {
    <# foreach (var property in Properties) { #>
        <#= property.PropertyType.FullName.ToResevedWordFullTypeName() #> <#= property.Name #> { get; set; }
    <# } #>

    <# foreach (var ev in Events) { 
    var genericArgs = ev.EventHandlerType.GetGenericArguments();
    #>
        Action? <#= ev.Name #>Action { get; set; }
        Action<<#= genericArgs.Length > 0 ? genericArgs[0].Name : "EventArgs" #>>? <#= ev.Name #>ActionWithArgs { get; set; }
    <# } #>

    }

    <# if (IsTypeNotAbstractWithEmptyConstructur()) { #>
    public partial class <#= TypeName() #><T> : <#= BaseTypeName() #><T>, I<#= TypeName() #> where T : <#= FullTypeName() #>, new()
    {
        public <#= TypeName() #>()
        { 
        
        }

        public <#= TypeName() #>(Action<T?> componentRefAction)
            : base(componentRefAction)
        {

        }
    <# } else { #>
    public abstract partial class <#= TypeName() #><T> : <#= BaseTypeName() #><T>, I<#= TypeName() #> where T : <#= FullTypeName() #>, new()
    {
        protected <#= TypeName() #>()
        { 
        
        }

        protected <#= TypeName() #>(Action<T?> componentRefAction)
            : base(componentRefAction)
        {

        }    
    <# } #>

        <# foreach (var property in Properties) { #>
        <#= property.PropertyType.FullName.ToResevedWordFullTypeName() #> I<#= TypeName() #>.<#= property.Name #> { get; set; } = (<#= property.PropertyType.FullName.ToResevedWordFullTypeName() #>)<#= FullTypeName() #>.<#= property.Name #>Property.DefaultValue;
        <# } #>

        <# foreach (var ev in Events) {
        var genericArgs = ev.EventHandlerType.GetGenericArguments(); #>
        Action? I<#= TypeName() #>.<#= ev.Name #>Action { get; set; }
        Action<<#= genericArgs.Length > 0 ? genericArgs[0].Name : "EventArgs" #>>? I<#= TypeName() #>.<#= ev.Name #>ActionWithArgs { get; set; }
        <# } #>

        protected override void OnUpdate()
        {
            OnBeginUpdate();
            <# if (Properties.Any()) { #>

            Validate.EnsureNotNull(NativeControl);
            var thisAsI<#= TypeName() #> = (I<#= TypeName() #>)this;
            <# foreach (var property in Properties) { #>
            if (NativeControl.<#= property.Name #> != thisAsI<#= TypeName() #>.<#= property.Name #>) NativeControl.<#= property.Name #> = thisAsI<#= TypeName() #>.<#= property.Name #>;
            <# } #>

            <# } #>

            base.OnUpdate();

            OnEndUpdate();
        }

        partial void OnBeginUpdate();
        partial void OnEndUpdate();

        <# if (Events.Any()) { #>
        protected override void OnAttachNativeEvents()
        {
            Validate.EnsureNotNull(NativeControl);

            var thisAsI<#= TypeName() #> = (I<#= TypeName() #>)this;
            <# foreach (var ev in Events) { #>
            if (thisAsI<#= TypeName() #>.<#= ev.Name #>Action != null || thisAsI<#= TypeName() #>.<#= ev.Name #>ActionWithArgs != null)
            {
                NativeControl.<#= ev.Name #> += NativeControl_<#= ev.Name #>;
            }
            <# } #>

            base.OnAttachNativeEvents();
        }

        <# foreach (var ev in Events) { 
        var genericArgs = ev.EventHandlerType.GetGenericArguments();
        #>
        private void NativeControl_<#= ev.Name #>(object? sender, <#= genericArgs.Length > 0 ? genericArgs[0].Name : "EventArgs" #> e)
        {
            var thisAsI<#= TypeName() #> = (I<#= TypeName() #>)this;
            thisAsI<#= TypeName() #>.<#= ev.Name #>Action?.Invoke();
            thisAsI<#= TypeName() #>.<#= ev.Name #>ActionWithArgs?.Invoke(e);
        }
        <# } #>

        protected override void OnDetachNativeEvents()
        {
            if (NativeControl != null)
            {
            <# foreach (var ev in Events) { #>
            NativeControl.<#= ev.Name #> -= NativeControl_<#= ev.Name #>;
            <# } #>
            }

            base.OnDetachNativeEvents();
        }
        <# } #>

    }

    <# if (IsTypeNotAbstractWithEmptyConstructur()) { #>
    public class <#= TypeName() #> : <#= TypeName() #><<#= FullTypeName() #>>
    {
        public <#= TypeName() #>()
        { 
        
        }

        public <#= TypeName() #>(Action<<#= FullTypeName() #>?> componentRefAction)
            : base(componentRefAction)
        {

        }
    }
    <# } #>

    public static partial class <#= TypeName() #>Extensions
    {
        <# foreach (var property in Properties) { #>
        public static T <#= property.Name #><T>(this T <#= TypeName().ToLowerInvariant() #>, <#= property.PropertyType.FullName.ToResevedWordFullTypeName() #> <#= property.Name.CamelCase() #>) where T : I<#= TypeName() #>
        {
            <#= TypeName().ToLowerInvariant() #>.<#= property.Name #> = <#= property.Name.CamelCase() #>;
            return <#= TypeName().ToLowerInvariant() #>;
        }
        <# if (property.PropertyType.Name == "Thickness") { #>
        public static T <#= property.Name #><T>(this T <#= TypeName().ToLowerInvariant() #>, double leftRight, double topBottom) where T : I<#= TypeName() #>
        {
            <#= TypeName().ToLowerInvariant() #>.<#= property.Name #> = new Thickness(leftRight, topBottom);
            return <#= TypeName().ToLowerInvariant() #>;
        }
        public static T <#= property.Name #><T>(this T <#= TypeName().ToLowerInvariant() #>, double uniformSize) where T : I<#= TypeName() #>
        {
            <#= TypeName().ToLowerInvariant() #>.<#= property.Name #> = new Thickness(uniformSize);
            return <#= TypeName().ToLowerInvariant() #>;
        }
        <# } #>
        <# if (property.Name == "FontSize") { #>
        public static T <#= property.Name #><T>(this T <#= TypeName().ToLowerInvariant() #>, NamedSize size) where T : I<#= TypeName() #>
        {
            <#= TypeName().ToLowerInvariant() #>.<#= property.Name #> = Device.GetNamedSize(size, typeof(<#= TypeName() #>));
            return <#= TypeName().ToLowerInvariant() #>;
        }
        <# } #>
        <# if (property.PropertyType.Name == "ImageSource") { 
               var propertyName = property.Name.Length <= 6 ? property.Name : property.Name.Substring(0, property.Name.Length - 6); #>
        public static T <#= propertyName #><T>(this T <#= TypeName().ToLowerInvariant() #>, string file) where T : I<#= TypeName() #>
        {
            <#= TypeName().ToLowerInvariant() #>.<#= property.Name #> = ImageSource.FromFile(file);
            return <#= TypeName().ToLowerInvariant() #>;
        }
        public static T <#= propertyName #><T>(this T <#= TypeName().ToLowerInvariant() #>, string fileAndroid, string fileiOS) where T : I<#= TypeName() #>
        {
            <#= TypeName().ToLowerInvariant() #>.<#= property.Name #> = Device.RuntimePlatform == Device.Android ? ImageSource.FromFile(fileAndroid) : ImageSource.FromFile(fileiOS);
            return <#= TypeName().ToLowerInvariant() #>;
        }
        public static T <#= propertyName #><T>(this T <#= TypeName().ToLowerInvariant() #>, string resourceName, Assembly sourceAssembly) where T : I<#= TypeName() #>
        {
            <#= TypeName().ToLowerInvariant() #>.<#= property.Name #> = ImageSource.FromResource(resourceName, sourceAssembly);
            return <#= TypeName().ToLowerInvariant() #>;
        }
        public static T <#= propertyName #><T>(this T <#= TypeName().ToLowerInvariant() #>, Uri imageUri) where T : I<#= TypeName() #>
        {
            <#= TypeName().ToLowerInvariant() #>.<#= property.Name #> = ImageSource.FromUri(imageUri);
            return <#= TypeName().ToLowerInvariant() #>;
        }
        public static T <#= propertyName #><T>(this T <#= TypeName().ToLowerInvariant() #>, Uri imageUri, bool cachingEnabled, TimeSpan cacheValidity) where T : I<#= TypeName() #>
        {
            <#= TypeName().ToLowerInvariant() #>.<#= property.Name #> = new UriImageSource
            {
                Uri = imageUri,
                CachingEnabled = cachingEnabled,
                CacheValidity = cacheValidity
            };
            return <#= TypeName().ToLowerInvariant() #>;
        }
        public static T <#= propertyName #><T>(this T <#= TypeName().ToLowerInvariant() #>, Func<Stream> imageStream) where T : I<#= TypeName() #>
        {
            <#= TypeName().ToLowerInvariant() #>.<#= property.Name #> = ImageSource.FromStream(imageStream);
            return <#= TypeName().ToLowerInvariant() #>;
        }
        <# } #>

        <# } #>
        
        <# foreach (var ev in Events) {
        var genericArgs = ev.EventHandlerType.GetGenericArguments();
        #>
        public static T On<#= ev.Name #><T>(this T <#= TypeName().ToLowerInvariant() #>, Action <#= ev.Name.ToLowerInvariant() #>Action) where T : I<#= TypeName() #>
        {
            <#= TypeName().ToLowerInvariant() #>.<#= ev.Name #>Action = <#= ev.Name.ToLowerInvariant() #>Action;
            return <#= TypeName().ToLowerInvariant() #>;
        }

        public static T On<#= ev.Name #><T>(this T <#= TypeName().ToLowerInvariant() #>, Action<<#= genericArgs.Length > 0 ? genericArgs[0].Name : "EventArgs" #>> <#= ev.Name.ToLowerInvariant() #>ActionWithArgs) where T : I<#= TypeName() #>
        {
            <#= TypeName().ToLowerInvariant() #>.<#= ev.Name #>ActionWithArgs = <#= ev.Name.ToLowerInvariant() #>ActionWithArgs;
            return <#= TypeName().ToLowerInvariant() #>;
        }
        <# } #>
    }
}
